/**
 @file SuperShader.vert
 @author Morgan McGuire, matrix@graphics3d.com
 */

/** World space point */
varying vec3 wsPosition;

/** Vector to the eye in tangent space (needed for parallax) */
varying vec3 _tsE;

/** Tangent space to world space.
    Note that this will be linearly interpolated across the polygon.

	NVIDIA drivers do not properly interpolate mat4, so we must pass
	the columns along a separate vectors. */
varying vec4 tan_X, tan_Y, tan_Z, tan_W;

/** Modelview projection matrix used for the light's shadow map */
uniform mat4 lightMVP;

/** Coordinate to use in the shadow map */
varying vec4 shadowCoord;

varying vec2 texCoord;

void main(void) {
    vec3 wsEyePos = g3d_CameraToWorldMatrix[3].xyz;
    vec3 osEyePos = (g3d_WorldToObjectMatrix * vec4(wsEyePos, 1)).xyz;
	vec3 osPosition  = gl_Vertex.xyz;

    // Object space eye vector
    vec3 osE = osEyePos - osPosition;

	// Compute the columns of the tangent space to world space matrix
	tan_X = g3d_ObjectToWorldMatrix * vec4(gl_MultiTexCoord1.xyz, 0);
	tan_Z = g3d_ObjectToWorldMatrix * vec4(normalize(gl_Normal), 0);

    // T and N are guaranteed perpendicular, so B is normalized.
	tan_Y = vec4(cross(tan_Z.xyz, tan_X.xyz), 0);
	tan_W = g3d_ObjectToWorldMatrix * gl_Vertex;

	wsPosition      = tan_W.xyz;

	// Compute the tangent space eye vector (ATI does not support the transpose operator)
    mat3 objectToTangent = mat3(tan_X.x, tan_Y.x, tan_Z.x,
                                tan_X.y, tan_Y.y, tan_Z.y,
                                tan_X.z, tan_Y.z, tan_Z.z);
    
	_tsE             = objectToTangent * osE;

    // Note that tan_W is objectToWorld * gl_Vertex
    shadowCoord      = lightMVP * tan_W;


	texCoord	     = gl_MultiTexCoord0.st;
    gl_Position      = ftransform();
}

